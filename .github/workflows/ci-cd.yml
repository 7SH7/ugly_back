name: Spring Boot CI/CD

# 워크플로우 트리거 조건
on:
  push:
    branches: [ main ]  # main  브랜치에 푸시 시 실행
  pull_request:
    branches: [ main ]           # main으로 PR 생성 시 실행
  workflow_dispatch:             # 수동 실행 옵션

jobs:
  # 1단계: test
  test:
    name: Test Application
    runs-on: ubuntu-latest

    steps:
      # 소스 코드 체크아웃
      - name: Checkout code
        uses: actions/checkout@v4

      # JDK 17 설정 / Gradle 캐싱
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: gradle

      # Gradle wrapper 실행 권한 부여
      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      # 테스트 실행
      - name: Run tests
        run: ./gradlew test

      # 테스트 결과 리포트 생성 :: 확인을 위해서..
      - name: Publish test report
        uses: dorny/test-reporter@v1
        if: always()  # 테스트 실패해도 결과 업로드
        with:
          name: JUnit Tests
          path: build/test-results/test/*.xml
          reporter: java-junit

  # 2단계: Docker 이미지
  build-and-push:
    name: Build and Push Docker Image
    needs: test  # test Job이 성공해야 실행
    runs-on: ubuntu-latest
    # main 브랜치에 푸시할 때만 실행 (PR에서는 실행 안 함)
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main')

    steps:
      # 소스 코드 체크아웃
      - name: Checkout code
        uses: actions/checkout@v4

      # JDK 17 설정 및 Gradle 캐싱
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: gradle

      # Gradle wrapper 실행 권한 부여
      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      # Gradle 빌드 (테스트 제외)
      - name: Build with Gradle
        run: ./gradlew build -x test

      # Docker Buildx 설정 (고급 빌드 기능 활성화)
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # dockerHub 로그인
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # 브랜치 이름 추출 -> 태그에
      - name: Extract branch name
        shell: bash
        run: echo "BRANCH_NAME=$(echo ${GITHUB_REF#refs/heads/})" >> $GITHUB_ENV

      # Docker 이미지 빌드 및 푸시
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          # 여러 태그 적용: latest, 커밋해시
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/${{ secrets.DOCKER_REPO }}:latest
            ${{ secrets.DOCKER_USERNAME }}/${{ secrets.DOCKER_REPO }}:${{ github.sha }}
          # Docker 레이어 캐싱 (빌드 속도 향상)
          cache-from: type=registry,ref=${{ secrets.DOCKER_USERNAME }}/${{ secrets.DOCKER_REPO }}:buildcache
          cache-to: type=registry,ref=${{ secrets.DOCKER_USERNAME }}/${{ secrets.DOCKER_REPO }}:buildcache,mode=max

  # 3단계: 배포
  deploy-simple:
    name: Simple Deployment
    needs: build-and-push  # build-and-push Job이 성공해야 실행
    runs-on: ubuntu-latest
    # main 브랜치에 푸시할 때만 실행
    if: github.ref == 'refs/heads/main'

    steps:
      # EC2 서버에 SSH 접속하여 배포 스크립트 실행
      - name: Deploy to server
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: ${{ secrets.EC2_PORT }}
          script: |
            echo "=== 배포 시작 ==="
            
            # 최신 이미지 가져오기
            echo "=== 최신 Docker 이미지 가져오기 ==="
            docker pull ${{ secrets.DOCKER_USERNAME }}/${{ secrets.DOCKER_REPO }}:latest
            
            # 환경 변수 파일 생성
            echo "=== 환경 변수 파일 생성 ==="
            cat > .env << EOL
            # Spring Boot 설정
            SPRING_PROFILES_ACTIVE=${{ secrets.SPRING_PROFILE }}
            
            # 데이터베이스 설정
            MYSQL_HOST=${{ secrets.MYSQL_HOST }}
            MYSQL_PORT=${{ secrets.MYSQL_PORT }}
            MYSQL_DB=${{ secrets.MYSQL_DB }}
            MYSQL_USERNAME=${{ secrets.MYSQL_USERNAME }}
            MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }}
            
            # 외부 API 설정 
            OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
            
            # AWS 설정 
            AWS_ACCESS_KEY=${{ secrets.AWS_ACCESS_KEY }}
            AWS_SECRET_KEY=${{ secrets.AWS_SECRET_KEY }}
            AWS_REGION=${{ secrets.AWS_REGION }}
            EOL
            
            # 기존 컨테이너 중지 및 제거
            echo "=== 기존 컨테이너 중지 및 제거 ==="
            docker stop ${{ secrets.CONTAINER_NAME }} || true
            docker rm ${{ secrets.CONTAINER_NAME }} || true
            
            # 새 컨테이너 실행
            echo "=== 새 컨테이너 실행 ==="
            docker run -d --name ${{ secrets.CONTAINER_NAME }} \
              -p 8080:8080 \
              --env-file .env \
              --restart unless-stopped \
              --log-driver json-file \
              --log-opt max-size=10m \
              --log-opt max-file=3 \
              ${{ secrets.DOCKER_USERNAME }}/${{ secrets.DOCKER_REPO }}:latest
            
            # 컨테이너 시작 확인
            echo "=== 컨테이너 시작 확인 ==="
            sleep 5
            if docker ps -q -f "name=${{ secrets.CONTAINER_NAME }}" | grep -q .; then
              echo "컨테이너가 성공적으로 시작되었습니다."
              docker ps -f "name=${{ secrets.CONTAINER_NAME }}"
            else
              echo "컨테이너 시작에 실패했습니다."
              echo "컨테이너 로그:"
              docker logs ${{ secrets.CONTAINER_NAME }} || echo "로그를 가져올 수 없습니다."
              exit 1
            fi
            
            # 사용하지 않는 Docker 이미지 정리 :: 이번엔 정리 안 함.
#            echo "=== Docker 시스템 정리 ==="
#            docker image prune -f
            
            echo "=== 배포 완료 ==="
